def req(p, j, pos, jumps, n):
    if p + 1 == n:
        return j
    if p >= n or jumps[p] < 1:
        return 10e10
    
    """
    Пояснение к последней развилке. 
    1) Если jumps[p] == 0, то это значит, что мы не можем никуда прыгать, 
    то есть этот путь нам не подходит. При этом, нам не важно, что находится в jumps[-1]. Так как при обработке последней 
    позиции мы просто возвращаем количество прыжков. 
    
    2) Если jumps[p] < 0, то нам так же неинтересен этот путь. Допустим, что jumps[p] < 0 и при этом наиболее оптимальный путь лежит 
    лежит через вершину p. В таком случае, нам необходимо будет прыгать на позицию в отрезке [p - jumps[p]; p]. Но при этом 
    из любой вершины мы можем прыгать на любое расстояние [i; i + jumps[i]], в таком случае, мы могли прийти в одну из предыдущих 
    позиций из позиции, стоящей раньше неё, на один прыжок, уменьшая длину пути; А следовательно, путь, ведущий через jumps[p] 
    (jumps[p] < 0) не был оптимальным. Противоречие => не имеет смысла обрабатывать точки для которых jumps[p] < 0. Через них не
    идут оптимальные пути.

    Наверняка где-то запустался и написал пургу, но было интересно :D
    """
        
    return min(req(p + x, j + 1, pos, jumps, n) for x in range(1, min(jumps[p], n - p) + 1))


def jump(jumps: list[int]) -> int:
    n = len(jumps)
    pos = [0] * n

    return req(0, 0, pos, jumps, n)


jumps = [2,3, 0,1,4]
assert jump(jumps) == 2
